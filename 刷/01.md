**若要重载+、=、<<、=和[ ]运算符，则必须作为类成员重载的运算符是**

- ＝和[]

C++语言规定，运算符“=”、“[]”、“()”、“->”以及所有的类型转换运算符只能作为成员函数重载

---

**静态的使用注意事项：**

1.静态方法只能访问静态成员（包括成员变量和成员方法）

  非静态方法可以访问静态也可以访问非静态

2.静态方法中不可以定义this，super关键字

  因为 一个类中，一个static变量只会有一个内存空间，虽然有多个类实例，但这些类实例中的这个static变量会共享同一个内存空间。静态方法在优先于对象存在，所以静态方法中不可以出现this，super关键字。

3.主函数是静态的。

程序运行的时候，[静态成员](https://www.baidu.com/s?wd=静态成员&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Yzn1mvn1m4mWwBPjnsrH610ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPWcdPHDLn1bYnj64njf3nj0Y)已经加载在内存里面了，但是包含[静态成员](https://www.baidu.com/s?wd=静态成员&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Yzn1mvn1m4mWwBPjnsrH610ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPWcdPHDLn1bYnj64njf3nj0Y)的对象共享这些[静态成员](https://www.baidu.com/s?wd=静态成员&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Yzn1mvn1m4mWwBPjnsrH610ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPWcdPHDLn1bYnj64njf3nj0Y)，
比方说，A有一个静态成员public static int i;那么程序运行的时候，这个i就加载进内存了，A的所有对象的i变量都指向这个静态空间的i，也就是说创建对象之前，它就占空间了

1：只有类的成员函数才能说明为虚函数； 
2：静态成员函数不能是虚函数； 
3：内联函数不能为虚函数； 
4：构造函数不能是虚函数； 
5：析构函数可以是虚函数，而且通常声明为虚函数

---

要判断奇偶数, 直接用二进制最后一位去比较就可以.

if(n & 1) cout << "奇数" << endl; else cout << "偶数" << endl;

n & (n-1) 的作用是把n的最低位1设置为0; 

 XXX10000 -> XXX00000

所以这个表达式(n & (n-1) ) == 0 可以用来判断n是否是0 或者2的整数倍.

---

x = x&(x-1);//求x的二进制表达式有多少个1

x = x|(x-1);//求x的二进制表达式有多少个0

---

私有成员调用，需要加上该私有成员的的归属类

---

```c++
#include <stdio.h>
int main(){
    int a[] = { 2, 4, 6, 8 }, *p = a, i;
    for(i = 0;i < 4;i++)
        a[i] = *p++;
    printf("%d\n", a[2]);
}
```

程序的输出结果是（） 

- 6

注解：

- *p++ 先取指针p指向的值（数组第一个元素2），再将指针p自增1
- (*p)++ 先去指针p指向的值（数组第一个元素2），再将该值自增1（数组第一个元素变为3）
- *++p 先将指针p自增1（此时指向数组第二个元素）， 操作再取出该值
- ++*p 先取指针p指向的值（数组第一个元素2），再将该值自增1（数组第一个元素变为3）

`*和++`的优先级是同级，但是根据右结合，等同于 `*（p++）`，是这么说没错。但是，++后置的时候，本身含义就是先运算后加1。这里的先运算就是说把 p++当成一个整体。`*p++`符号整体对外表现的值是`*p`的值，运算完成后p再加1。

---

**有关动态分配和静态分配：**

所谓动态内存分配就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不象数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。例如我们定义一个float型数组：float score[100]; 但是，在使用数组的时候，总有一个问题困扰着我们：数组应该有多大？在很多的情况下，你并不能确定要使用多大的数组，比如上例，你可能并不知道我们要定义的这个数组到底有多大，那么你就要把数组定义得足够大。这样，你的程序在运行时就申请了固定大小的你认为足够大的内存空间。即使你知道你想利用的空间大小，但是如果因为某种特殊原因空间利用的大小有增加或者减少，你又必须重新去修改程序，扩大数组的存储范围。这种分配固定大小的内存分配方法称之为静态内存分配。但是这种内存分配的方法存在比较严重的缺陷，特别是处理某些问题时：在大多数情况下会浪费大量的内存空间，在少数情况下，当你定义的数组不够大时，可能引起下标越界错误，甚至导致严重后果。

我们用动态内存分配就可以解决上面的问题. 所谓动态内存分配就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不象数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。从以上动、静态内存分配比较可以知道动态内存分配相对于静态内存分配的特点：

1、不需要预先分配存储空间；

2、分配的空间可以根据程序的需要扩大或缩小。

   **说白了，内存的静态分配和动态分配的区别主要是两个：**

​    一是时间不同。静态分配发生在程序编译和连接的时候。动态分配则发生在程序调入和执行的时候。

   二是空间不同。**堆都是动态分配的，没有静态分配的堆**。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由函数alloca（）进行分配。**不过栈的动态分配和堆不同，他的动态分配是由编译器进行释放，无需我们手工实现。**  

​    对于一个进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。动态数据区一般就是“堆栈”。“栈(stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。

​    一般，用static修饰的变量，全局变量位于静态数据区。函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。

**静态分配是在编译阶段就确定大小的，堆不能进行静态分配，堆是在运行过程中分配的。**

**栈也可以通过函数进行动态分配，释放时由编译器自己自动释放 。**

---

当函数为虚函数时，子类继承基类会完全覆盖基类虚函数，**强制指针类型转换无法改变类内虚函数的函数体**；

虚函数调用与指针类型无关，基类调用基类虚函数，子类调用子类虚函数；

若为普通函数，普通函数同名但未被覆盖，优先匹配与指针类型匹配的同名函数；

即base类型指针调用base内部函数；Derived类型指针调用Derived类内函数；

---

```
 ``int``* p1和``int` `*p1没有区别，都是表示P1是一个整数型指针，P1指针指向a所在地址，
P2指向b所在地址，所以将值赋给指针时，要么在值前面加地址符，即p1或p2=&a;
要么对指针进行解引,即*p1或*p2=a。
```

---

#### 声明枚举变量三种方法

#### 1、先声明枚举类型后定义枚举类型变量

```c++
enum WeekdayType  
{  
    sun,mou,tue,wed,thu,fri,sat  
};  
enum WeekdayType today,yesterday,tomorrow;
```

#### 2、声明枚举类型的同时定义枚举类型变量

```c++
enum WeekdayType  
{  
    sun,mou,tue,wed,thu,fri,sat   
}today,yesterday,tomorrow;
```

#### 3、直接定义枚举类型变量 (可以有无名枚举,下面这种写法就是)

```c++
enum  
{  
    sun,mou,tue,wed,thu,fri,sat  
}today,yesterday,tomorrow;
```

---

32位机器上定义如下结构体：

```c++
struct xx {
    long long _x1;
    char _x2;
    int _x3;
    char _x4[2];
    static int _x5;
};
int xx::_x5;
```

请问sizeof(xx)的大小是（） === 24 

解答：

> 1-8的地址分给了_x1 ,
>
> 9分给了_x2，
>
> 13-16分给了_x3,  int要按4对齐所以10-13的空间其实是浪费了
>
> 17-18分给了_x4，
>
> _x5不占用空类间， 
>
> 最后本身是需要按照8对其
>
> 所以19-24也被占用了

---

### 友元函数

1.友元只是破坏了类的**隐藏性**和**封装性**，不能被继，没有this指针。
2.可以直接调用，不需要通过对象或者指针。

---

**构造函数不能声明为虚函数的原因是:**
1 构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象 的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。

2 虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初 始化，将无法进行。

---

**C++ 文件到生成exe文件需要经过预处理、编译、汇编和链接几个步骤。**

- 预处理：在预处理阶段，编译器主要作加载头文件、宏替换、条件编译的作用。
- 编译：在编译过程中，编译器主要作语法检查和词法分析。可以通过使用 -S 选项来进行查看，该选项预处理之后的结果翻译成汇编代码。
- 汇编：在汇编过程中，编译器把汇编代码转化为机器代码。

- 链接：链接就是将目标文件、启动代码、库文件链接成可执行文件的过程。

---

```c++
#include <stdio. h>
int fun( int a )
{
    int b = 0;
    static int c = 3;
    a = ( c + +,b + + );
    return ( a );
}
main( )
{
    int a = 2,i,k;
    for( i = 0;i<2;i + + )
        k = fun( a + + );
    printf("%d\n",k );
}
```

程序输出结果是？    0 

> fun函数返回的a值和传入的a值无关，每次循环得到的k值和上一次循环也无关，所以直接看最后一次循环结果就好，不过要注意**c值和fun()函数的调用次数是有关的**。
>
> 结果的关键在于**逗号表达式 a=(c++,b++);** 看了大家的解析，想要提一点，以下两个表达式结果是不同的：
>
> 1. **a=(表达式1,表达式2);**
> 2. **a=表达式1,表达式2;**
>
> 因为**逗号运算符**在所有运算符中**优先级最低**，所以表达式（2）实际上执行过程为 (a=表达式1),表达式2; 所以这道题中：
>
> 1. **若 a=(c++,b++); 则a=0，**因为逗号表达式为(c++,b++)，这个表达式的结果是0，并将这个结果赋值给a；
> 2. **若 a=c++,b++; 则a=4，**因为逗号表达式为(a=c++,b++)，这个表达式结果为0，但赋给a的值是自加前的c值；
>
> 下面简单讲下逗号表达式是什么鬼：
>
> 逗号表达式的形式就是用逗号运算符将若干个表达式分隔开，形如：
>
> 表达式1,表达式2,......,表达式n
>
> 它是一个整体，所以上式其实是（表达式1,表达式2,......,表达式n ），运算过程为从左往右逐个表达式计算，整个表达式结果是表达式n的结果。

---

```c++
#include<stdio.h>
int main(){
    short *p,*q;
    short arr[15] = {0};
    p = q = arr;
    p++;
    printf("%d,", p - q);
    printf("%d,", (char*)p - (char*)q);
    printf("%d", sizeof(arr) / sizeof(*arr));
}
```

执行结果：

1,2,15

> 指针自增、自减每次移动的偏移量是指针所指向对象的字节大小，所以p++与q的偏移量是2个字节。
>
> 指针相减的值是指针地址的偏移除以指针每次移位的大小；
>
> 1)p-q=1;偏移量为2个字节，每次移动2个字节，所以为1
>
> 2)(char *)p-(char *)q，指针的偏移没变，但是每次指针移位是按照（char*）类型移动，即每次移动1个字节，所以是2
>
> 3）数字每次元素2个字节，所以sizeof(arr)为30，sizeof(*arr)为2。

---

**下列运算符重载函数中，属于友元函数的是（）**

```c++
Base operator+(Base);
Base operator--(Base);
Base operator&&(Base, Base);
Base operator++(Base,int);
```

BCD

  因为友元函数没有当前对象，因此要定义单目运算符，就需要单参函数，要定义双目运算符，就需要双参函数；

  定义后置“++"或后置“--"运算是特例，它们是单目运算符，但需要两个形参，头一个形参是作用对象，后一个是int形参；

  用友元函数可以定义成员函数不能实现的运算，例如一些双目运算符，右操作数是本类对象，而左操作数不是本类对象；

  成员函数体中，当前对象作为一个操作数，无形参形式可以定义单目运算符；

---

```c++
class A{
   int i;
};
class B{
   A *p;
public:
   B(){p=new A;}
   ~B(){delete p;}
};
void sayHello(B b){
}
int main(){
   B b;
   sayHello(b);
}
```

上述代码会导致程序运行崩溃

为了清晰可见，我们从新把题目代码码一遍：

```c++
class A{
   int i;
};
class B{
   A *p;
public:
   B(){p=new A;}
   ~B(){delete p;}
   /*
   B(const B& ths){
	   p = ths.p;
   }*/
};
void sayHello(B x){
}
int main(){
   B b;
   sayHello(b);
}
```

这里的错误原因是编译器在生成default copy construction的时候使用的bitwise copy语义，也就是只是简单的浅拷贝。 ***上面被注释掉的程序就是编译器自动添加的部分。*** 从而导致在sayHello中向参数x传递值时，调用了bitwise copy的拷贝构造函数，使得x对象和b对象中的值完全一致，包括p指针的值，在x离开作用域（也就是sayHello函数结束），x发生析构，调用delete 销毁了指针p，同时在main函数结束的时候，析构b时又会调用一次delete删除指针p。

也就是本程序会delete一直已经被delete 的指针。可以做如下改进，来修复程序：

```c++
class A{
   int i;
};
class B{
   A *p;
public:
   B(){p=new A;}
   ~B(){delete p;}
   B(const B& other){
	   p = new A;		//构建新的指针
	   *p = *(other.p);	//将指向的内容复制，依然指向不同的位置
   }
};
void sayHello(B b){
}
int main(){
   B b;
   sayHello(b);
}
```

如上，在B中添加copy 构造函数

默认的拷贝构造函数是浅拷贝，直接把指针的值复制了一份。调用sayHello，离开作用域，调用析构函数delete了一次。main函数中，又delete了一次。因此程序崩溃。

---

一个.cpp文件会生成一个.obj文件，.h文件不会生成.obj文件

---

**const说明变量是常量，常量存储在常量区，在编译时就直接将其替换成相应的引用**

---

**dynamic_cast** 专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。

**dynamic_cast** 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。

**static_cast** 用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换。另外，如果对象所属的类重载了强制类型转换运算符 T（如 T 是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。

---

extern "C" 的作用是为了能够正确的实现 C++ 代码调用 C 语言代码。加上 extern "C" 后，会指示编译器这部分代码按照 C 语言（而不是 C++）的方式进行编译。由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 这个功能十分有用处，因为在 C++ 出现以前，很多代码都是 C 语言写的，而且很底层的库也是 C 语言写的，为了更好的支持原来的 C 代码和已经写好的 C 语言库，需要在 C++ 中尽可能的支持 C，而 extern "C" 就是其中的一个策略。

---

对象创建时代码的加载顺序为：静态代码 --> 非静态代码 --> 构造方法。

若继承了父类，则加载顺序为：父类的静态的代码 --> 子类的静态的代码 --> 父类内部非静态代码 --> 父类的构造方法 --> 子类的非静态代码 --> 子类的构造方法。

其中，静态代码包括（静态方法，静态变量，静态代码块等），非静态代码即（成员方法，成员变量，成员代码块等），同一种代码，写在上面的先加载。

---

**在构造函数中需要初始化列表初始化的有如下三种情况** 

1.带有const修饰的类成员 ，如const int a ；

2.引用成员数据，如 int& p;

3.带有引用的类变量

---

**Linux内核下的存储主要分为5大段：栈、堆、数据段、代码段、不可访问区域；**

栈：又称“运行时栈”，按照“后进先出”原则操作数据，主要存储局部变量，用完即销毁。

堆：又称“运行时堆”，是一块自由存储区域，由用户手动申请和销毁空间，一般和malloc, free, calloc, realloc等内存操作关键字一起出现。、

数据段：主要由三部分组成（.bass段、.data段、.rodata段），.bass主要存放未初始化静态数据；.data存放已经初始化静态数据；.rodata存放只读数据（常量）。

代码段：主要分两部分（.text和.init），.text存放用户程序代码；.init存放可执行程序初始化代码。

---

**指针和引用的敏感词与区别** 
★ 相同点：

1. 都是地址的概念；
2. 指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。

★ 区别：

1. 指针是一个实体，而引用仅是个别名；
2. 引用使用时无需解引用(*)，指针需要解引用；
3. 引用只能在定义时被初始化一次，之后不可变；指针可变；
4. 引用不能为空，指针可以为空；
5. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；
6. 指针和引用的自增(++)运算意义不一样；
   8.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。

---

**位与运算符"&"的优先级比"+"低**

---

重载运算符，坚持4个“不”原则: 1)运算符操作数的个数; 2)运算符原有优先级; 3)运算符原有的结合性; 4)运算符原有的语法结构 均不能改变！！！

---

```c++
class A {
    int a;
    short b;
    int c;
    char d;
};
class B {
    double a;
    short b;
    int c;
    char d;
};
```

**在32位机器上用gcc编译以上代码，求sizeof(A)，sizeof(B)分别是（）**---- 16 , 24

字节对齐的题很常见的。

原则有3条（楼上已经说了），讲一下自己的理解：

\1. 结构体变量的首地址 必须 是内部最宽数据类型的倍数（虽然和做题没什么关系）

\2. 按顺序一个变量一个变量看，要求current变量的首地址 必须是自己大小的倍数。

\3. 到了最后一个变量，要求整个结构体的大小的最宽数据类型的倍数。

那么看一下 这道 题：

A: int a    （4个字节）                         4

short b   (2个字节，起始地址4是2的倍数，不补)    4+2

int c     (4个字节，4+2不是4的倍数，被2个 )    4+2+2（补）+4

char d    (1个字节，4+2+2+4是1的倍数，不补)  4+2+2（补）+4 +1

最后补3个字节，让整体大小为4的倍数   4+2+2(补)+4+1+3（补） =16

B: double a    （8个字节）                         8

short b   (2个字节，起始地址8是2的倍数，不补)    8+2

int c     (4个字节，8+2不是4的倍数，被2个 )    8+2+2（补）+4

char d    (1个字节，8+2+2+4是1的倍数，不补)  8+2+2（补）+4 +1

最后补7个字节，让整体大小为8的倍数   8+2+2(补)+4+1+7（补） =24

---

\>>是位移符号。可以理解为每次除以2. 

从k=2000直到k=1，共需10次位移操作

---

**在64位系统下，分别定义如下两个变量：char *p[10]; char(*p1)[10];请问，sizeof(p)和sizeof (p1)分别值为_80, 8___**

```c++
重点理解p跟谁结合了，跟[]结合，则p就是一个数组;跟*结合，p就是一个指针；

首先[]()的优先级一样，均大于*

char *p[10]，p与[]结合，所以p就是一个数组，数组的元素比较特殊，是指针，指针大小为8，所以是10*8=80；

char(*p1)[10]，与*结合，所以是一个指针，大小为8

char *p[10] 是指针数组,数组里存放了10个指针,在64位系统下指针占8个字节,所以sizeof(p) = 10 * 8 = 80.

char (*p1)[10]是数组指针,p1是一个指向存放10个char类型的数组的指针,所以sizeof(p1) = 8.
```

---

**遇到const修饰的时候，从右向左读 最容易区分**

```c++
const int *p1;//则const 修饰的是int *p1 说明这个变量是不能变的，就是p1所指向的变量是常量变量

int const *p2 = &i; //const修饰的是  *p2(表示所指向的变量)  说明p2所指的变量不能改变，也就是 指向常量变量。

int *const p3 = &i;  //const修饰的是  p3  说明指针变量的值不能改变，也就是不能让p3指针再指向其他值
```

---

**对于函数传字符串或者通过malloc分配内存，都需要使用二级指针。**

---

BSS段：通常是指用来存放程序中**未初始化的全局变量**的一块内存区域；

数据段：通常是指用来存放程序中 **已初始化** **的** **全局变量** 的一块内存区域，static意味着在数据段中存放变量；

代码段：通常是指用来存放 程序执行代码 的一块内存区域；

堆：存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减，这一块在程序运行前就已经确定了；

栈：栈又称堆栈， 存放程序的 局部变量 （不包括static声明的变量）。除此以外，在函数被调用时，栈用来传递参数和返回值。

---

```c++
char (*p)[N]和char *p[N]
[]的优先级高于*

char *p[N]
指针数组，数组有N个元素
p是一个有N个元素的数组，元素的类型是 char *

char (*p)[N]
指向一维数组的指针，一维数组只能有N个元素
p是一个指针，指向一个有十个char元素的数组
```

---

x&(x-1)统计1的个数，x|(x+1)统计0的个数

---

函数调用语句中实参的个数是（3 ）

```c++
exce((v1, v2), (v3, v4, v5), v6);
```

---

枚举赋值问题，从上一个定义开始逐个递增

---

函数：fopen

**函数原型：**FILE * fopen(const char * path,const char * mode);

**返回值：**文件顺利打开后，[指](http://baike.baidu.com/item/指/65525)向该流的[文件指针](http://baike.baidu.com/item/文件指针)就会被返回。如果文件打开失败则返回NULL，并把[错误代码](http://baike.baidu.com/item/错误代码)存在[errno](http://baike.baidu.com/item/errno)中。

一般而言，打开文件后会做一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以一般在fopen()后作错误判断及处理。

**参数说明：**

参数path[字符](http://baike.baidu.com/item/字符)串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。

mode有下列几种形态[字符串](http://baike.baidu.com/item/字符串):

“r” 以[只读](http://baike.baidu.com/item/只读)方式打开文件，该文件必须存在。

**“r+” 以可读写方式打开文件，该文件必须存在。**

”rb+“ 读写打开一个[二进制文件](http://baike.baidu.com/item/二进制文件)，允许读写数据（可以任意修改），文件必须存在。

“w” 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。

“w+” 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。

“a” 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（[EOF](http://baike.baidu.com/item/EOF)符保留）

”a+“ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）

“wb” 只写打开或新建一个[二进制文件](http://baike.baidu.com/item/二进制文件)；只允许写数据（若文件存在则文件长度清为零，即该文件内容会消失）。

“wb+” 读写打开或建立一个二进制文件，允许读和写（若文件存在则文件长度清为零，即该文件内容会消失）

“wx” 创建文本文件,只允许写入数据.[C11]

“wbx” 创建一个二进制文件,只允许写入数据.[C11]

”w+x“ 创建一个文本文件,允许读写.[C11]

“wb+x” 创建一个二进制文件,允许读写.[C11]

“w+bx” 和"wb+x"相同[C11]

“rt” 只读打开一个文本文件，只允许读数据
“wt” 只写打开或建立一个文本文件，只允许写数据
“at” 追加打开一个文本文件，并在文件末尾写数据
“rb” 只读打开一个二进制文件，只允许读数据
“wb” 只写打开或建立一个二进制文件，只允许写数据
“ab” 追加打开一个二进制文件，并在文件末尾写数据
“rt+” 读写打开一个文本文件，允许读和写
“wt+” 读写打开或建立一个文本文件，允许读写
“at+” 读写打开一个文本文件，允许读，或在文件末追加数据
“rb+” 读写打开一个二进制文件，允许读和写
“ab+” 读写打开一个二进制文件，允许读，或在文件末追加数据

---

定义二维数组并赋初值时，可以省略第一维的大小，但不能省略第二维的大小

---

**（c++）（ios::app）解决文件写入时，新内容覆盖掉旧的。**

```c++
ofs.open(fileName, ios::out | ios::app);  // 这句作用是，如果没有文件，生成空文件；
```

如果有文件，在文件尾追加

```c++
ios::app | ios::out
```

如果只有ios::out
新内容会对就内容产生覆盖。
更具体的指令参照下面

![在这里插入图片描述](.\img\1.jpg)

总结：

![在这里插入图片描述](.\img\2.jpg)



![img](.\img\3.jpg)

---

**1.****缓冲文件系统**

缓冲文件系统是借助于文件结构体指针FILE *来对文件进行管理，通过文件指针对文件进行访问，即可以读写字符、字符串、格式化数据，也可以读写二进制数据。

缓 冲文件系统特点：在内存中开辟一个“缓冲区”，为程序里每一个文件使用，当执行读文件操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓 冲区”依次读入接收的变量。执行写文件操作时，也是先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大 小，影响着实际操作外在的次数，内存“缓冲区”越大，则操作外存的次数就越少，执行速度就越快，效率就越高。一般来说，文件“缓冲区”的大小跟机器是相关 的。

缓冲文件系统的IO函数主要包括：fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等。

**2.****非缓冲文件系统**

非缓冲文件系统依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件（对于UNIX系统内核而言，文本文件和二进制代码文件并无区别），但效率高、速度快，由于ANSI标准不再包括非缓冲文件系统，因此，在读取正规的文件时，建议大家最好不要选择它。

非缓冲文件系统的IO函数主要包括：open, close, read, write, getc, getchar, putc, putchar等

https://www.cnblogs.com/ldp-web/archive/2011/10/21/2220180.html

---

vector::erase()：从指定容器删除指定位置的元素或某段范围内的元素
vector::erase()方法有两种重载形式
如下：
iterator erase(  iterator _Where);
iterator erase(  iterator _First,  iterator _Last);
如果是删除指定位置的元素时：
返回值是一个迭代器，指向删除元素下一个元素;

如果是删除某范围内的元素时：返回值也表示一个迭代器，指向最后一个删除元素的下一个元素;

或者这么理解，在进行单个元素删除后，传入的[迭代器](https://so.csdn.net/so/search?q=迭代器&spm=1001.2101.3001.7020)指向不变，仍然指向被删除元素的位置，而被删除元素之后的所有元素都向前移动一位，也就是该迭代器实际上是指向了原来被删除元素的下一个元素。

---

派生类的成员函数可以直接访问基类的公有成员和保护成员。

“派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。”“派生类访问说明符的目的是控制派生类用户对于基类成员的访问权限。”

可见，即使是private继承，派生类成员也是可以访问基类的public和protected成员的，只是这些成员在派生类里都为private性质的*(就好像普通的类成员可以访问自己类里的私有成员一样)*，而派生类构造的对象不能访问（就好像在类外访问类中的私有成员）。

---

数组做函数参数，会退化成指针

---

**如果只想静态产生类对象，那么僵new和delete操作符设置为私有的；如果只想动态产生类对象，那么将析构函数设置为私有的（不能继承）或者是保护（可继承）。**

---

X定义如下，若存在X a; a.x=0x11223344;则a.y[1]的值可能为 ---- 22（大端）  或者 33 （小端）

```c++
union X{
    int x;
    char y[4]; 
};
```

0x表示16进制，若小端存储，低位存储在低地址，0x44是最低位，存放在最低的地址为y[0]，所以y[1]=0x33。——————————————————————若大端存储，高位存储在低地址，0x11是最高位，存放在最低的地址为y[0]，所以y[1]=0x22

---

**下面程序的执行结果： ** 22221111

```c++
class A{ 
    public: 
        long a; 
}; 
class B : public A { 
    public: 
        long b; 
}; 
void seta(A* data, int idx) { 
    data[idx].a = 2; 
} 
int main(int argc, char *argv[]) { 
    B data[4]; 
    for(int i=0; i<4; ++i){ 
        data[i].a = 1; 
        data[i].b = 1; 
        seta(data, i); 
    } 
    for(int i=0; i<4; ++i){ 
         std::cout << data[i].a << data[i].b; 
    } 
    return 0; 
}

[(1, 1),(1, 1),(1, 1),(1, 1)]
[(2, 2),(2, 2),(1, 1),(1, 1)]
```

这道题应该注意 指针类型加减 时步长的问题。

A 大小为 4

B 大小为 8

那么：

void seta(A* data, int idx) {

  data[idx].a = 2;

}

由于传入的实参为B类型，大小为8，而形参为A类型，大小为4

data[idx] 取 data + idx 处的元素，这时指针 data加1 的长度不是一个B长度，而是一个A长度，或者说是1/2个B长度。这时该函数中 data[0~3] 指向的是原 data[0].a,data[0].b,data[1].a,data[1].b,

由于隐式类型转换的缘故，data[0].a, data[0].b,data[1].a,data[1].b 处的值全部由于 data[idx].a = 2; 操作变为 2。

这道题如果改为void seta(B* data, int idx)，那么形参中data指针加1步长为8，结果就是21212121。但是由于步长为4，所以结果就是 22221111。

---

for循环里面的执行顺序：

```c++
for(A;B;C)
{
   D;
}
```

A->B->D->C->B->D->C...

---

对于类而言： 栈上创建的对象，如果有默认拷贝构造函数，就不要加括号，即Test b; 如果加了括号会被编译器误认为是函数声明，如：Test b(); 返回类型为Test ，函数名为b，形参为空。

---

struct结构体变量大小等于结构体中的各个成员变量所占内存大小总和，union共用体变量大小等于共用体结构中占用内存最大的成员的内存大小。

枚举类型，本质上是一组常数的集合体，由于枚举变量的赋值，一次只能存放枚举结构中的某个常数。所以枚举变量的大小，实质是常数所占内存空间的大小

---

**64位系统下有 `char ** p[4];` 请问 `sizeof p` 的值是多少**

p 是个数组，所以 sizeof(p) 返回数组的占用大小，64 位情况下

【char **p[4] 】 表示 【char** 数组】 返回 4 * 8 = 32

【char *(*p)[4] 】 表示 【指向 char* 数组的指针】 返回 8

【char (**p)[4] 】 表示 【指向 char 数组的指针的指针】 返回 8

---

static的成员变量属于类域，不算入对象的sizeof中

---

